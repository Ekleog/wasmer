// Do not edit: This code was generated by flatdata's generator.
#[allow(missing_docs)]
pub mod wasmer_cache {
#[repr(transparent)]
#[derive(Clone)]
pub struct TrapInformation {
    data: [u8; 5],
}

impl TrapInformation {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }
}

impl flatdata::Struct for TrapInformation {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }

    const SIZE_IN_BYTES: usize = 5;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl TrapInformation {
    pub fn new( ) -> Self {
        Self{data : [0; 5]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 5]) -> &Self {
        // Safety: This is safe since TrapInformation is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 5]) -> &mut Self {
        // Safety: This is safe since TrapInformation is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 5] {
        &self.data
    }
}

impl Default for TrapInformation {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for TrapInformation {}

impl TrapInformation {
    #[inline]
    pub fn code_offset(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 0, 32);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn trap_code(&self) -> super::wasmer_cache::TrapCode {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 32, 4);
        unsafe { std::mem::transmute::<u32, super::wasmer_cache::TrapCode>(value) }
    }

}

impl std::fmt::Debug for TrapInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("TrapInformation")
            .field("code_offset", &self.code_offset())
            .field("trap_code", &self.trap_code())
            .finish()
    }
}

impl std::cmp::PartialEq for TrapInformation {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.code_offset() == other.code_offset() &&        self.trap_code() == other.trap_code()     }
}

impl TrapInformation {
    #[inline]
    #[allow(missing_docs)]
    pub fn set_code_offset(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 0, 32)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_trap_code(&mut self, value: super::wasmer_cache::TrapCode) {
        flatdata_write_bytes!(u32; value, self.data, 32, 4)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &TrapInformation) {
        self.set_code_offset(other.code_offset());
        self.set_trap_code(other.trap_code());
    }
}
#[repr(transparent)]
#[derive(Clone)]
pub struct InstructionAddressMap {
    data: [u8; 20],
}

impl InstructionAddressMap {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 20]}
    }
}

impl flatdata::Struct for InstructionAddressMap {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 20]}
    }

    const SIZE_IN_BYTES: usize = 20;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl InstructionAddressMap {
    pub fn new( ) -> Self {
        Self{data : [0; 20]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 20]) -> &Self {
        // Safety: This is safe since InstructionAddressMap is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 20]) -> &mut Self {
        // Safety: This is safe since InstructionAddressMap is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 20 {
            assert_eq!(data.len(), 20);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 20];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 20 {
            assert_eq!(data.len(), 20);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 20];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 20] {
        &self.data
    }
}

impl Default for InstructionAddressMap {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for InstructionAddressMap {}

impl InstructionAddressMap {
    #[inline]
    pub fn srcloc(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 0, 32);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn code_offset(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 32, 64);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    #[inline]
    pub fn code_len(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 96, 64);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for InstructionAddressMap {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("InstructionAddressMap")
            .field("srcloc", &self.srcloc())
            .field("code_offset", &self.code_offset())
            .field("code_len", &self.code_len())
            .finish()
    }
}

impl std::cmp::PartialEq for InstructionAddressMap {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.srcloc() == other.srcloc() &&        self.code_offset() == other.code_offset() &&        self.code_len() == other.code_len()     }
}

impl InstructionAddressMap {
    #[inline]
    #[allow(missing_docs)]
    pub fn set_srcloc(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 0, 32)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_code_offset(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 32, 64)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_code_len(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 96, 64)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &InstructionAddressMap) {
        self.set_srcloc(other.srcloc());
        self.set_code_offset(other.code_offset());
        self.set_code_len(other.code_len());
    }
}
#[repr(transparent)]
#[derive(Clone)]
pub struct FunctionAddressMapLocation {
    data: [u8; 24],
}

impl FunctionAddressMapLocation {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 24]}
    }
}

impl flatdata::Struct for FunctionAddressMapLocation {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 24]}
    }

    const SIZE_IN_BYTES: usize = 24;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl FunctionAddressMapLocation {
    pub fn new( ) -> Self {
        Self{data : [0; 24]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 24]) -> &Self {
        // Safety: This is safe since FunctionAddressMapLocation is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 24]) -> &mut Self {
        // Safety: This is safe since FunctionAddressMapLocation is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 24 {
            assert_eq!(data.len(), 24);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 24];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 24 {
            assert_eq!(data.len(), 24);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 24];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 24] {
        &self.data
    }
}

impl Default for FunctionAddressMapLocation {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for FunctionAddressMapLocation {}

impl FunctionAddressMapLocation {
    #[inline]
    pub fn start_srcloc(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 0, 32);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn end_srcloc(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 32, 32);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn body_offset(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 64, 64);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    #[inline]
    pub fn body_len(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 128, 64);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for FunctionAddressMapLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("FunctionAddressMapLocation")
            .field("start_srcloc", &self.start_srcloc())
            .field("end_srcloc", &self.end_srcloc())
            .field("body_offset", &self.body_offset())
            .field("body_len", &self.body_len())
            .finish()
    }
}

impl std::cmp::PartialEq for FunctionAddressMapLocation {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.start_srcloc() == other.start_srcloc() &&        self.end_srcloc() == other.end_srcloc() &&        self.body_offset() == other.body_offset() &&        self.body_len() == other.body_len()     }
}

impl FunctionAddressMapLocation {
    #[inline]
    #[allow(missing_docs)]
    pub fn set_start_srcloc(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 0, 32)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_end_srcloc(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 32, 32)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_body_offset(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 64, 64)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_body_len(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 128, 64)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &FunctionAddressMapLocation) {
        self.set_start_srcloc(other.start_srcloc());
        self.set_end_srcloc(other.end_srcloc());
        self.set_body_offset(other.body_offset());
        self.set_body_len(other.body_len());
    }
}
#[derive(Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum TrapCode {
    Stackoverflow = 0,
    Heapsetteroutofbounds = 1,
    Heapaccessoutofbounds = 2,
    Heapmisaligned = 3,
    Tablesetteroutofbounds = 4,
    Tableaccessoutofbounds = 5,
    Outofbounds = 6,
    Indirectcalltonull = 7,
    Badsignature = 8,
    Integeroverflow = 9,
    Integerdivisionbyzero = 10,
    Badconversiontointeger = 11,
    Unreachablecodereached = 12,
    Interrupt = 13,
    Unalignedatomic = 14,
    Vmoutofmemory = 15,
}

impl flatdata::helper::Int for TrapCode {
    const IS_SIGNED: bool = false;
}



#[derive(Clone)]
pub struct FunctionAddressMap {
    _storage: flatdata::StorageHandle,
    instructions : &'static [super::wasmer_cache::InstructionAddressMap],
    loc : &'static super::wasmer_cache::FunctionAddressMapLocation,
}

impl FunctionAddressMap {
    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn instructions(&self) -> &[super::wasmer_cache::InstructionAddressMap] {
        self.instructions
    }

    #[inline]
    pub fn loc(&self) -> &super::wasmer_cache::FunctionAddressMapLocation {
        self.loc
    }

}

impl ::std::fmt::Debug for FunctionAddressMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("FunctionAddressMap")
            .field("instructions", &self.instructions())
            .field("loc", &self.loc())
            .finish()
    }
}

impl FunctionAddressMap {
    pub fn open(storage: flatdata::StorageHandle)
        -> ::std::result::Result<Self, flatdata::ResourceStorageError>
    {
        #[allow(unused_imports)]
        use flatdata::SliceExt;
        // extend lifetime since Rust cannot know that we reference a cache here
        #[allow(unused_variables)]
        let extend = |x : Result<&[u8], flatdata::ResourceStorageError>| -> Result<&'static [u8], flatdata::ResourceStorageError> {x.map(|x| unsafe{std::mem::transmute(x)})};

        storage.read(&Self::signature_name("FunctionAddressMap"), schema::function_addressmap::FUNCTION_ADDRESSMAP)?;

        let resource = extend(storage.read("instructions", schema::function_addressmap::resources::INSTRUCTIONS));
        let instructions = resource.map(|x| <&[super::wasmer_cache::InstructionAddressMap]>::from_bytes(x))??;
        let resource = extend(storage.read("loc", schema::function_addressmap::resources::LOC));
        let loc = resource.map(|x| super::wasmer_cache::FunctionAddressMapLocation::from_bytes_slice(x))??;

        Ok(Self {
            _storage: storage,
            instructions,
            loc,
        })
    }
}

/// Builder for creating [`FunctionAddressMap`] archives.
///
///[`FunctionAddressMap`]: struct.FunctionAddressMap.html
#[derive(Clone, Debug)]
pub struct FunctionAddressMapBuilder {
    storage: flatdata::StorageHandle
}

impl FunctionAddressMapBuilder {
    #[inline]
    /// Stores [`instructions`] in the archive.
    ///
    /// [`instructions`]: struct.FunctionAddressMap.html#method.instructions
    pub fn set_instructions(&self, vector: &[super::wasmer_cache::InstructionAddressMap]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("instructions", schema::function_addressmap::resources::INSTRUCTIONS, vector.as_bytes())
    }

    /// Opens [`instructions`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`instructions`]: struct.FunctionAddressMap.html#method.instructions
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_instructions(&self) -> ::std::io::Result<flatdata::ExternalVector<super::wasmer_cache::InstructionAddressMap>> {
        flatdata::create_external_vector(&*self.storage, "instructions", schema::function_addressmap::resources::INSTRUCTIONS)
    }

    #[inline]
    /// Stores [`loc`] in the archive.
    ///
    /// [`loc`]: struct.FunctionAddressMap.html#method.loc
    /// Stores [`loc`] in the archive.
    pub fn set_loc(&self, resource: &super::wasmer_cache::FunctionAddressMapLocation) -> ::std::io::Result<()> {
        let data = resource.as_bytes();
        self.storage.write("loc", schema::function_addressmap::resources::LOC, data)
    }

}

impl FunctionAddressMapBuilder {
    pub fn new(
        storage: flatdata::StorageHandle,
    ) -> Result<Self, flatdata::ResourceStorageError> {
        flatdata::create_archive("FunctionAddressMap", schema::function_addressmap::FUNCTION_ADDRESSMAP, &storage)?;
        Ok(Self { storage })
    }
}




#[derive(Clone)]
pub struct CompiledFunctionFrameInfo {
    _storage: flatdata::StorageHandle,
    traps : &'static [super::wasmer_cache::TrapInformation],
    address_map : super::wasmer_cache::FunctionAddressMap
,
}

impl CompiledFunctionFrameInfo {
    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn traps(&self) -> &[super::wasmer_cache::TrapInformation] {
        self.traps
    }

    #[inline]
    pub fn address_map(&self) -> &super::wasmer_cache::FunctionAddressMap {
        &self.address_map
    }

}

impl ::std::fmt::Debug for CompiledFunctionFrameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("CompiledFunctionFrameInfo")
            .field("traps", &self.traps())
            .field("address_map", &self.address_map())
            .finish()
    }
}

impl CompiledFunctionFrameInfo {
    pub fn open(storage: flatdata::StorageHandle)
        -> ::std::result::Result<Self, flatdata::ResourceStorageError>
    {
        #[allow(unused_imports)]
        use flatdata::SliceExt;
        // extend lifetime since Rust cannot know that we reference a cache here
        #[allow(unused_variables)]
        let extend = |x : Result<&[u8], flatdata::ResourceStorageError>| -> Result<&'static [u8], flatdata::ResourceStorageError> {x.map(|x| unsafe{std::mem::transmute(x)})};

        storage.read(&Self::signature_name("CompiledFunctionFrameInfo"), schema::compiled_functionframe_info::COMPILED_FUNCTIONFRAME_INFO)?;

        let resource = extend(storage.read("traps", schema::compiled_functionframe_info::resources::TRAPS));
        let traps = resource.map(|x| <&[super::wasmer_cache::TrapInformation]>::from_bytes(x))??;
        let address_map = super::wasmer_cache::FunctionAddressMap::open(storage.subdir("address_map"))?;

        Ok(Self {
            _storage: storage,
            traps,
            address_map,
        })
    }
}

/// Builder for creating [`CompiledFunctionFrameInfo`] archives.
///
///[`CompiledFunctionFrameInfo`]: struct.CompiledFunctionFrameInfo.html
#[derive(Clone, Debug)]
pub struct CompiledFunctionFrameInfoBuilder {
    storage: flatdata::StorageHandle
}

impl CompiledFunctionFrameInfoBuilder {
    #[inline]
    /// Stores [`traps`] in the archive.
    ///
    /// [`traps`]: struct.CompiledFunctionFrameInfo.html#method.traps
    pub fn set_traps(&self, vector: &[super::wasmer_cache::TrapInformation]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("traps", schema::compiled_functionframe_info::resources::TRAPS, vector.as_bytes())
    }

    /// Opens [`traps`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`traps`]: struct.CompiledFunctionFrameInfo.html#method.traps
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_traps(&self) -> ::std::io::Result<flatdata::ExternalVector<super::wasmer_cache::TrapInformation>> {
        flatdata::create_external_vector(&*self.storage, "traps", schema::compiled_functionframe_info::resources::TRAPS)
    }

    /// Stores [`address_map`] in the archive.
    ///
    /// [`address_map`]: struct.CompiledFunctionFrameInfo.html#method.address_map
    #[inline]
    pub fn address_map(&self) -> Result<super::wasmer_cache::FunctionAddressMapBuilder, flatdata::ResourceStorageError> {
        let storage = self.storage.subdir("address_map");
        super::wasmer_cache::FunctionAddressMapBuilder::new(storage)
    }

}

impl CompiledFunctionFrameInfoBuilder {
    pub fn new(
        storage: flatdata::StorageHandle,
    ) -> Result<Self, flatdata::ResourceStorageError> {
        flatdata::create_archive("CompiledFunctionFrameInfo", schema::compiled_functionframe_info::COMPILED_FUNCTIONFRAME_INFO, &storage)?;
        Ok(Self { storage })
    }
}


#[doc(hidden)]
pub mod schema {
pub mod function_addressmap {

pub const FUNCTION_ADDRESSMAP: &str = r#"namespace wasmer_cache {
struct InstructionAddressMap
{
    srcloc : u32 : 32;
    code_offset : u64 : 64;
    code_len : u64 : 64;
}
}

namespace wasmer_cache {
struct FunctionAddressMapLocation
{
    start_srcloc : u32 : 32;
    end_srcloc : u32 : 32;
    body_offset : u64 : 64;
    body_len : u64 : 64;
}
}

namespace wasmer_cache {
archive FunctionAddressMap
{
    instructions : vector< .wasmer_cache.InstructionAddressMap >;
    loc : .wasmer_cache.FunctionAddressMapLocation;
}
}

"#;

pub mod resources {
pub const INSTRUCTIONS: &str = r#"namespace wasmer_cache {
struct InstructionAddressMap
{
    srcloc : u32 : 32;
    code_offset : u64 : 64;
    code_len : u64 : 64;
}
}

namespace wasmer_cache {
archive FunctionAddressMap
{
    instructions : vector< .wasmer_cache.InstructionAddressMap >;
}
}

"#;
pub const LOC: &str = r#"namespace wasmer_cache {
struct FunctionAddressMapLocation
{
    start_srcloc : u32 : 32;
    end_srcloc : u32 : 32;
    body_offset : u64 : 64;
    body_len : u64 : 64;
}
}

namespace wasmer_cache {
archive FunctionAddressMap
{
    loc : .wasmer_cache.FunctionAddressMapLocation;
}
}

"#;
}
}
pub mod compiled_functionframe_info {

pub const COMPILED_FUNCTIONFRAME_INFO: &str = r#"namespace wasmer_cache {
enum TrapCode : u32 : 4
{
    StackOverflow = 0,
    HeapSetterOutOfBounds = 1,
    HeapAccessOutOfBounds = 2,
    HeapMisaligned = 3,
    TableSetterOutOfBounds = 4,
    TableAccessOutOfBounds = 5,
    OutOfBounds = 6,
    IndirectCallToNull = 7,
    BadSignature = 8,
    IntegerOverflow = 9,
    IntegerDivisionByZero = 10,
    BadConversionToInteger = 11,
    UnreachableCodeReached = 12,
    Interrupt = 13,
    UnalignedAtomic = 14,
    VMOutOfMemory = 15,
}
}

namespace wasmer_cache {
struct TrapInformation
{
    code_offset : u32 : 32;
    trap_code : .wasmer_cache.TrapCode : 4;
}
}

namespace wasmer_cache {
struct InstructionAddressMap
{
    srcloc : u32 : 32;
    code_offset : u64 : 64;
    code_len : u64 : 64;
}
}

namespace wasmer_cache {
struct FunctionAddressMapLocation
{
    start_srcloc : u32 : 32;
    end_srcloc : u32 : 32;
    body_offset : u64 : 64;
    body_len : u64 : 64;
}
}

namespace wasmer_cache {
archive FunctionAddressMap
{
    instructions : vector< .wasmer_cache.InstructionAddressMap >;
    loc : .wasmer_cache.FunctionAddressMapLocation;
}
}

namespace wasmer_cache {
archive CompiledFunctionFrameInfo
{
    traps : vector< .wasmer_cache.TrapInformation >;
    address_map : archive .wasmer_cache.FunctionAddressMap;
}
}

"#;

pub mod resources {
pub const TRAPS: &str = r#"namespace wasmer_cache {
enum TrapCode : u32 : 4
{
    StackOverflow = 0,
    HeapSetterOutOfBounds = 1,
    HeapAccessOutOfBounds = 2,
    HeapMisaligned = 3,
    TableSetterOutOfBounds = 4,
    TableAccessOutOfBounds = 5,
    OutOfBounds = 6,
    IndirectCallToNull = 7,
    BadSignature = 8,
    IntegerOverflow = 9,
    IntegerDivisionByZero = 10,
    BadConversionToInteger = 11,
    UnreachableCodeReached = 12,
    Interrupt = 13,
    UnalignedAtomic = 14,
    VMOutOfMemory = 15,
}
}

namespace wasmer_cache {
struct TrapInformation
{
    code_offset : u32 : 32;
    trap_code : .wasmer_cache.TrapCode : 4;
}
}

namespace wasmer_cache {
archive CompiledFunctionFrameInfo
{
    traps : vector< .wasmer_cache.TrapInformation >;
}
}

"#;
pub const ADDRESS_MAP: &str = r#"namespace wasmer_cache {
struct InstructionAddressMap
{
    srcloc : u32 : 32;
    code_offset : u64 : 64;
    code_len : u64 : 64;
}
}

namespace wasmer_cache {
struct FunctionAddressMapLocation
{
    start_srcloc : u32 : 32;
    end_srcloc : u32 : 32;
    body_offset : u64 : 64;
    body_len : u64 : 64;
}
}

namespace wasmer_cache {
archive FunctionAddressMap
{
    instructions : vector< .wasmer_cache.InstructionAddressMap >;
    loc : .wasmer_cache.FunctionAddressMapLocation;
}
}

namespace wasmer_cache {
archive CompiledFunctionFrameInfo
{
    address_map : archive .wasmer_cache.FunctionAddressMap;
}
}

"#;
}
}
}
}
